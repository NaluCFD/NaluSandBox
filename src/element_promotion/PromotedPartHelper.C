/*------------------------------------------------------------------------*/
/*  Copyright 2014 Sandia Corporation.                                    */
/*  This software is released under the license detailed                  */
/*  in the file, LICENSE, which is located in the top-level Nalu          */
/*  directory structure                                                   */
/*------------------------------------------------------------------------*/
#include <element_promotion/PromotedPartHelper.h>

#include <stk_mesh/base/MetaData.hpp>
#include <stk_mesh/base/Part.hpp>
#include <stk_util/environment/ReportHandler.hpp>
#include <stk_topology/topology.hpp>

#include <algorithm>
#include <vector>
#include <string>

namespace sierra{
namespace naluUnit{

  // A set of functions to deal with part pairs having specific ending tags
  bool part_vector_is_valid(const stk::mesh::PartVector& parts) {
    return (std::find(parts.begin(), parts.end(), nullptr) == parts.end() && !parts.empty() );
  }
  //--------------------------------------------------------------------------
  std::string super_element_suffix()
  {
    return "se";
  }
  //--------------------------------------------------------------------------
  std::string super_element_part_name(std::string base_name)
  {
    ThrowAssertMsg(!base_name.empty(), "Empty base name for super elem part");
    return (base_name.insert(base_name.find_first_of("_"),super_element_suffix()));
  }
  //--------------------------------------------------------------------------
  std::string super_subset_part_name(const std::string& base_name, int numElemNodes, int numSideNodes)
  {
    // subsetted part name.  Goes like "surfacese_super512_superside64_1"
    // Ioss doesn't recognize "superf" but does recognize the "super" tag

    // Note: there's a 32 character limit on the maximum length of the
    // part name (Ioss throws a warning message), so economy on characters is good

    ThrowAssertMsg(!base_name.empty(), "Empty base name for super elem part");
    auto first_token = base_name.substr(0, base_name.find_first_of('_'));
    auto last_token = base_name.substr(base_name.find_last_of("_"),base_name.length());
    std::string name = first_token + super_element_suffix()
        + "_super"  + std::to_string(numElemNodes)
        + "_superside" + std::to_string(numSideNodes)
        + last_token;

    return name;
  }
  //--------------------------------------------------------------------------
  std::string base_element_part_name(std::string super_name)
  {
    ThrowRequireMsg(super_name.find(super_element_suffix()) != std::string::npos,
      "Not a super-element part name!");
    return (super_name.erase(super_name.find(super_element_suffix()),super_element_suffix().length()));
  }
  //--------------------------------------------------------------------------
  stk::mesh::Part* super_elem_part(const stk::mesh::Part& part)
  {
    return (part.mesh_meta_data().get_part(super_element_part_name(part.name())));
  }
  stk::mesh::Part* super_subset_part(const stk::mesh::Part& part, int numElemNodes, int numSideNodes)
  {
    return (part.mesh_meta_data().get_part(super_subset_part_name(part.name(), numElemNodes, numSideNodes)));
  }
  //--------------------------------------------------------------------------
  stk::mesh::Part* base_elem_part_from_super_elem_part(const stk::mesh::Part& super_elem_part)
  {
    return (super_elem_part.mesh_meta_data().get_part(base_element_part_name(super_elem_part.name())));
  }
  //--------------------------------------------------------------------------
  stk::mesh::Part* super_elem_part(const stk::mesh::Part* part)
  {
    ThrowAssert(part != nullptr);
    return (part->mesh_meta_data().get_part(super_element_part_name(part->name())));
  }
  //--------------------------------------------------------------------------
  void transform_to_super_elem_part_vector(stk::mesh::PartVector& parts)
  {
    ThrowAssert(part_vector_is_valid(parts));
    std::transform(parts.begin(), parts.end(), parts.begin(), [](stk::mesh::Part* part) {
      return super_elem_part(part);
    });
  }
  //------------------------------------------------------------------------
  bool is_super(const stk::mesh::Part* p) {
    return (p->topology().is_superedge()
         || p->topology().is_superface()
         || p->topology().is_superelement());
  }
  //------------------------------------------------------------------------
  bool is_side(const stk::mesh::Part* p) {
    return (p->mesh_meta_data().side_rank() == p->topology().side_rank());
  }
  //------------------------------------------------------------------------
  bool is_super_side(const stk::mesh::Part* p) {
    return (is_super(p) && is_side(p));
  }
   //------------------------------------------------------------------------
  stk::mesh::PartVector base_ranked_parts(const stk::mesh::PartVector& parts, stk::topology::rank_t rank)
  {
    ThrowAssert(part_vector_is_valid(parts));

    stk::mesh::PartVector elemParts;
    std::copy_if(parts.begin(), parts.end(), std::back_inserter(elemParts), [rank](stk::mesh::Part* p) {
      return (p->topology().rank() == rank && !is_super(p));
    });
    return elemParts;
  }
  //--------------------------------------------------------------------------
  stk::mesh::PartVector base_elem_parts(const stk::mesh::PartVector& parts)
  {
    return base_ranked_parts(parts, stk::topology::ELEM_RANK);
  }
  //--------------------------------------------------------------------------
  stk::mesh::PartVector only_super_parts(const stk::mesh::PartVector& parts)
  {
    ThrowAssert(part_vector_is_valid(parts));

    stk::mesh::PartVector elemParts;
    std::copy_if(parts.begin(), parts.end(), std::back_inserter(elemParts), [](stk::mesh::Part* p) {
      if (is_super(p)) {
        return true;
      }
      for (const auto* subset : p->subsets()) {
        if (is_super(subset)) {
          return true;
        }
      }
      return false;
    });
    return elemParts;
  }
  //--------------------------------------------------------------------------
  stk::mesh::PartVector only_super_elem_parts(const stk::mesh::PartVector& parts)
  {
    ThrowAssert(part_vector_is_valid(parts));

    stk::mesh::PartVector elemParts;
    std::copy_if(parts.begin(), parts.end(), std::back_inserter(elemParts), [](stk::mesh::Part* p) {
      return (p->topology().is_superelement());
    });
    return elemParts;
  }
  //--------------------------------------------------------------------------
  stk::mesh::PartVector only_super_side_parts(const stk::mesh::PartVector& parts)
  {
    ThrowAssert(part_vector_is_valid(parts));

    stk::mesh::PartVector faceParts;
    std::copy_if(parts.begin(), parts.end(), std::back_inserter(faceParts), [](stk::mesh::Part* p) {
      if (is_super(p) && is_side(p)) {
        return true;
      }
      for (const auto* subset : p->subsets()) {
        if (is_super(subset) && is_side(subset)) {
          return true;
        }
      }
      return false;
    });
    return faceParts;
  }
  //--------------------------------------------------------------------------
  stk::mesh::PartVector super_elem_part_vector(const stk::mesh::PartVector& parts)
  {
    auto baseElemParts = base_elem_parts(parts);
    transform_to_super_elem_part_vector(baseElemParts);
    return baseElemParts;
  }
  //--------------------------------------------------------------------------
  size_t
  num_sub_elements(
    const int dim,
    const stk::mesh::BucketVector& buckets,
    unsigned polyOrder)
  {
    ThrowRequire(dim == 2 || dim == 3);
    int faceSize = std::pow(polyOrder,dim-1);
    int elemSize = std::pow(polyOrder,dim);
    auto side_rank = (dim == 2) ? stk::topology::EDGE_RANK : stk::topology::FACE_RANK;
    unsigned numEntities = 0;
    for (const auto* ib : buckets) {
      unsigned subElemsPerElem = (ib->topology().rank() == side_rank) ? faceSize : elemSize;
      numEntities += ib->size()*subElemsPerElem;
    }
    return numEntities;
  }
  //--------------------------------------------------------------------------
  size_t
  count_entities(const stk::mesh::BucketVector& buckets)
  {
    unsigned numEntities = 0;
    for (const auto* ib : buckets) {
      numEntities += ib->size();
    }
    return numEntities;
  }

} // namespace naluUnit
}  // namespace sierra
